/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * Please import the `PrismaClient` class from the `client.ts` file instead.
 */
import * as runtime from "@prisma/client/runtime/client";
const config = {
    "previewFeatures": [],
    "clientVersion": "7.2.0",
    "engineVersion": "0c8ef2ce45c83248ab3df073180d5eda9e8be7a3",
    "activeProvider": "mongodb",
    "inlineSchema": "generator client {\n  provider = \"prisma-client\"\n  // binaryTargets = [\"native\", \"windows\", \"linux-musl-openssl-3.0.x\"]\n  output   = \"../src/generated/prisma\"\n}\n\ndatasource db {\n  provider = \"mongodb\"\n}\n\n// commits submitted need to to be verified by the user before it becomes merged\n// in this version, commits are automatically MERGED\nenum CommitStatus {\n  PENDING\n  REJECTED\n  MERGED\n}\n\n// three possible commit policies for commit overlapping\nenum CommitPolicy {\n  SERIAL\n  FORK\n  MERGE\n}\n\n// user model needed to be created\nmodel User {\n  id                String        @id @default(auto()) @map(\"_id\") @db.ObjectId\n  username          String?       @unique\n  metadata          UserMetadata? // the metadata to be displayed for the user, by default not required\n  wallet            String        @unique // walet address of the user\n  repositories      Repository[] // repositories created by the user\n  commits           Commit[] // commits created by the user\n  createdAt         DateTime      @default(now())\n  updatedAt         DateTime      @default(now())\n  nftCredit         Int           @default(100)\n  lastCreditUpdated DateTime      @default(now())\n}\n\nmodel Repository {\n  id             String             @id @default(auto()) @map(\"_id\") @db.ObjectId\n  name           String // name of the repository needs to be mandatorily as a main parameter\n  repoHash       String             @unique\n  branches       Branch[] // a single repository might contain serveral branches\n  writeAccessIds String[]           @default([]) // list of wallet addresses of the contribtors who can write to the repository. Iniitialized with the wallet addrdess of the creator\n  adminIds       String[]           @default([]) // list of admins that can give and revoke write permissions and delete the repository\n  contributorIds String[]           @default([]) // initialized\n  metadata       RepositoryMetdata? // optional metadata that needs to be added\n  createdAt      DateTime           @default(now())\n  updatedAt      DateTime           @default(now()) // timestamp of the latest update\n  // the owner of the repository\n  ownerAddress   String\n  ownerId        String             @db.ObjectId\n  owner          User               @relation(fields: [ownerId], references: [id], onDelete: Cascade)\n  // base model stored as an IpfsObject\n  baseModelHash  String?            @unique // the base model hash can be used to check if the base model is already present\n  baseModelId    String?            @db.ObjectId\n  baseModel      IpfsObject?        @relation(\"RepositoryBaseModel\", fields: [baseModelId], references: [id])\n  // the base model CID can be fetched from `baseModel.cid`\n  collection     Collection?        @relation(fields: [collectionId], references: [id])\n  collectionId   String?            @unique @db.ObjectId\n  // the commit policy routes\n  commitPolicy   CommitPolicy       @default(MERGE)\n\n  @@unique([ownerAddress, name])\n}\n\n// repository contains branches\nmodel Branch {\n  id             String             @id @default(auto()) @map(\"_id\") @db.ObjectId\n  name           String // name of the branch\n  branchHash     String             @unique\n  description    String? // description of the branch's purpose\n  latestParamsId String?            @db.ObjectId // points to IpfsObject containing latest params\n  latestParams   IpfsObject?        @relation(\"BranchLatestParams\", fields: [latestParamsId], references: [id]) // reference to IPFS object for latest params\n  createdAt      DateTime           @default(now())\n  updatedAt      DateTime           @default(now()) // timestamp of the last commit\n  commits        Commit[] // commits in that branch\n  // the repository to which the branch belongs\n  repositoryId   String             @db.ObjectId // repository id for this branch\n  repository     Repository         @relation(fields: [repositoryId], references: [id], onDelete: Cascade)\n  SharedFolder   SharedFolderFile[] // shared folder is basically an array of shared folder files\n}\n\n// branches contain commits\n// a single commit happens from only a single person\n// not like the way currently federated learning happens\nmodel Commit {\n  id                 String       @id @default(auto()) @map(\"_id\") @db.ObjectId\n  commitHash         String       @unique // hash of the current commit\n  previousCommitHash String       @default(\"_GENESIS_COMMIT_\") // parent commit hash; first commit uses _GENESIS_COMMIT_\n  status             CommitStatus // the status of this particuar commit\n  rejectedMessage    String? // (Optional) Fwhy the commit was rejected in case it was rejected.  \n  message            String // commit message\n  paramHash          String       @unique // hash of the parmeters for the commit\n  params             Params? // the param is stored as a separate model\n  createdAt          DateTime     @default(now()) // when the commit was created  \n  statusUpdatedAt    DateTime?    @default(now()) // when the status was last updated\n  // for the current version the metric is an optional field\n  metrics            Metric? // the metrics of the model (e.g. accuracy, loss etc.)\n  architecture       String // new field included\n  // which branch the commit belongs to\n  branchId           String       @db.ObjectId\n  // when the branch is deleted so are the commmits in the branch\n  branch             Branch       @relation(fields: [branchId], references: [id])\n  committerAddress   String // wallet address of the contributor  \n  // when the user is deleted the commit is not deleted\n  committerId        String       @db.ObjectId\n  committer          User         @relation(fields: [committerId], references: [id])\n  isDeleted          Boolean      @default(false) // a commit is only soft deleted\n  // Nft converted commit properties\n  nft                Nft?         @relation(\"CommitToNft\", fields: [nftId], references: [id], onDelete: NoAction, onUpdate: Cascade)\n  nftId              String?      @unique @db.ObjectId\n  verified           Boolean      @default(false) // if the ZKML proof of the model has been verified\n\n  @@unique([branchId, previousCommitHash])\n}\n\n// the parameters are going to be a large file so its better to store in in its own schema\nmodel Params {\n  id           String     @id @default(auto()) @map(\"_id\") @db.ObjectId\n  ipfsObjectId String     @unique @db.ObjectId\n  ipfsObject   IpfsObject @relation(\"ParamsIpfs\", fields: [ipfsObjectId], references: [id])\n  // sharedFolderId   String            @unique @db.ObjectId\n  // sharedFolderFile SharedFolderFile? @relation(fields: [sharedFolderId], references: [id]) // points to the shared folder file\n  commitId     String     @unique @db.ObjectId // needs to be unique for a one to one relationship\n  commit       Commit     @relation(fields: [commitId], references: [id])\n  ZKMLProof    ZKMLProof? @relation(\"paramToProof\", fields: [zkmlProofId], references: [id], onDelete: SetNull)\n  zkmlProofId  String?    @unique @db.ObjectId\n}\n\n// the shared folder file is going to be deleted for v2\n// defining the shared folder model for storing the latest training data\nmodel SharedFolderFile {\n  id                         String   @id @default(auto()) @map(\"_id\") @db.ObjectId\n  branchId                   String   @db.ObjectId\n  // when the branch is deleted so are the commmits in the branch\n  branch                     Branch   @relation(fields: [branchId], references: [id])\n  // params                     Params? // back relation to the params object, non included shared folders in commits will not have the params property fulled\n  committerAddress           String // who has done the training\n  metrics_after_aggregation  Bytes[] // bytes array for the metrics before aggregation\n  metrics_before_aggregation Bytes[] // bytes array for the metrics after aggregation\n  // for the current version we are not storing the model after aggregation\n  model                      Bytes? // stores the pickled model of that file\n  createdAt                  DateTime @default(now()) // we always need the latest shared folder for this branch and this user\n}\n\nmodel ZKMLProof {\n  id                    String      @id @default(auto()) @map(\"_id\") @db.ObjectId\n  proofIpfsId           String?     @unique @db.ObjectId\n  proof                 IpfsObject? @relation(\"proofIPFS\", fields: [proofIpfsId], references: [id])\n  settingsIpfsId        String?     @unique @db.ObjectId\n  settings              IpfsObject? @relation(\"settingsIPFS\", fields: [settingsIpfsId], references: [id])\n  verificationKeyIpfsId String?     @unique @db.ObjectId\n  verification_key      IpfsObject? @relation(\"verificationKeyIPFS\", fields: [verificationKeyIpfsId], references: [id])\n  param                 Params?     @relation(\"paramToProof\")\n  paramId               String?     @unique @db.ObjectId\n}\n\n// These schemas can never be deleted\n// merkleTree model that stores the current merkle tree adress and how many can be implemented\n// only admin accessible\nmodel MerkleTree {\n  id              String   @id @default(auto()) @map(\"_id\") @db.ObjectId\n  mintAuthority   String // public key of the wallet that has mint authority on this merkleTree\n  active          Boolean  @default(false) // if this is the current merkle tree that is being used\n  address         String   @unique // public key of the merkle tree\n  signature       String   @unique // signature of the merkle tree creation signature\n  secret          String   @unique // secret key of the merkle tree\n  assetIds        String[] @unique // the assetIds minted in this merkle tree\n  totalLeaves     Int // total leaves in the merkle tree\n  remainingLeaves Int // leaves remaining where NFTs can be minted\n  createdAt       DateTime @default(now())\n}\n\n// details for the nft collection i.e. a repository\nmodel Collection {\n  id          String      @id @default(auto()) @map(\"_id\") @db.ObjectId\n  address     String      @unique\n  signature   String      @unique\n  privateKey  String      @unique\n  owner       String\n  repository  Repository?\n  nft         Nft[]\n  createdAt   DateTime    @default(now())\n  metadataCID String? // metadata of the collection uploaded to IPFS\n}\n\n// details of the nft\nmodel Nft {\n  id                String      @id @default(auto()) @map(\"_id\") @db.ObjectId\n  assetId           String      @unique\n  merkleTreeAddress String\n  signature         String      @unique\n  owner             String\n  createdAt         DateTime    @default(now())\n  // back relation to the commit schema\n  commit            Commit?     @relation(\"CommitToNft\")\n  collection        Collection? @relation(fields: [colectionId], references: [id])\n  colectionId       String      @unique @db.ObjectId\n  metadataCID       String? // CID of the metadata of the Nft uploaded to IPFS\n}\n\ntype Metric {\n  accuracy Float\n  loss     Float\n}\n\n// metadata type as an embedded document\ntype UserMetadata {\n  name         String?\n  email        String?\n  displayText  String?\n  profileImage String? // base 64 encoded image of the user\n  bio          String? // bio of the user\n}\n\ntype RepositoryMetdata {\n  name        String\n  description String?\n  useCase     String?\n  creator     String // wallet address that has created the Repository\n  framework   String\n}\n\n// the ipfs object model for all the objects uploaded to ipfs\nmodel IpfsObject {\n  id        String   @id @default(auto()) @map(\"_id\") @db.ObjectId\n  cid       String   @unique // cid of the object\n  uri       String   @unique\n  createdAt DateTime @default(now())\n  extension String\n  size      Float\n\n  // back-relations\n  repositories           Repository[] @relation(\"RepositoryBaseModel\")\n  branches               Branch[]     @relation(\"BranchLatestParams\")\n  params                 Params[]     @relation(\"ParamsIpfs\")\n  zkmlProofsProof        ZKMLProof[]  @relation(\"proofIPFS\")\n  zkmlProofsSettings     ZKMLProof[]  @relation(\"settingsIPFS\")\n  zkmlProofsVerification ZKMLProof[]  @relation(\"verificationKeyIPFS\")\n}\n\n// Commit creation session for the three-step commit flow\nmodel CommitCreationSession {\n  id          String    @id @default(auto()) @map(\"_id\") @db.ObjectId\n  jti         String    @unique\n  pk          String\n  repoId      String?   @db.ObjectId\n  branchId    String?   @db.ObjectId\n  status      String    @default(\"INITIATED\") // INITIATED | ZKML_VERIFIED | ZKML_UPLOADED | PARAMS_UPLOADED | FINALIZED | ERROR\n  createdAt   DateTime  @default(now())\n  expiresAt   DateTime?\n  lastErrorAt DateTime?\n  errorCount  Int       @default(0)\n  consumed    Boolean   @default(false)\n\n  // Track uploaded ZKML IPFS IDs for cleanup on failure\n  zkmlProofIpfsId    String? @db.ObjectId\n  zkmlSettingsIpfsId String? @db.ObjectId\n  zkmlVkIpfsId       String? @db.ObjectId\n\n  // Track uploaded params IPFS ID for cleanup on failure\n  paramsIpfsId String? @db.ObjectId\n}\n\n// Tracks users blocked from initiating commits for 2 minutes after errors\nmodel InitiationBlock {\n  pk           String   @id @map(\"_id\")\n  blockedUntil DateTime\n  createdAt    DateTime @default(now())\n}\n\n// the base model data must also include its details now\ntype BaseModelData {\n  extension String\n  size      Float\n}\n",
    "runtimeDataModel": {
        "models": {},
        "enums": {},
        "types": {}
    }
};
config.runtimeDataModel = JSON.parse("{\"models\":{\"User\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"_id\"},{\"name\":\"username\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"metadata\",\"kind\":\"object\",\"type\":\"UserMetadata\"},{\"name\":\"wallet\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"repositories\",\"kind\":\"object\",\"type\":\"Repository\",\"relationName\":\"RepositoryToUser\"},{\"name\":\"commits\",\"kind\":\"object\",\"type\":\"Commit\",\"relationName\":\"CommitToUser\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"nftCredit\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"lastCreditUpdated\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null},\"Repository\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"_id\"},{\"name\":\"name\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"repoHash\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"branches\",\"kind\":\"object\",\"type\":\"Branch\",\"relationName\":\"BranchToRepository\"},{\"name\":\"writeAccessIds\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"adminIds\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"contributorIds\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"metadata\",\"kind\":\"object\",\"type\":\"RepositoryMetdata\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"ownerAddress\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"ownerId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"owner\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"RepositoryToUser\"},{\"name\":\"baseModelHash\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"baseModelId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"baseModel\",\"kind\":\"object\",\"type\":\"IpfsObject\",\"relationName\":\"RepositoryBaseModel\"},{\"name\":\"collection\",\"kind\":\"object\",\"type\":\"Collection\",\"relationName\":\"CollectionToRepository\"},{\"name\":\"collectionId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"commitPolicy\",\"kind\":\"enum\",\"type\":\"CommitPolicy\"}],\"dbName\":null},\"Branch\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"_id\"},{\"name\":\"name\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"branchHash\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"description\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"latestParamsId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"latestParams\",\"kind\":\"object\",\"type\":\"IpfsObject\",\"relationName\":\"BranchLatestParams\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"commits\",\"kind\":\"object\",\"type\":\"Commit\",\"relationName\":\"BranchToCommit\"},{\"name\":\"repositoryId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"repository\",\"kind\":\"object\",\"type\":\"Repository\",\"relationName\":\"BranchToRepository\"},{\"name\":\"SharedFolder\",\"kind\":\"object\",\"type\":\"SharedFolderFile\",\"relationName\":\"BranchToSharedFolderFile\"}],\"dbName\":null},\"Commit\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"_id\"},{\"name\":\"commitHash\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"previousCommitHash\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"status\",\"kind\":\"enum\",\"type\":\"CommitStatus\"},{\"name\":\"rejectedMessage\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"message\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"paramHash\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"params\",\"kind\":\"object\",\"type\":\"Params\",\"relationName\":\"CommitToParams\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"statusUpdatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"metrics\",\"kind\":\"object\",\"type\":\"Metric\"},{\"name\":\"architecture\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"branchId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"branch\",\"kind\":\"object\",\"type\":\"Branch\",\"relationName\":\"BranchToCommit\"},{\"name\":\"committerAddress\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"committerId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"committer\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"CommitToUser\"},{\"name\":\"isDeleted\",\"kind\":\"scalar\",\"type\":\"Boolean\"},{\"name\":\"nft\",\"kind\":\"object\",\"type\":\"Nft\",\"relationName\":\"CommitToNft\"},{\"name\":\"nftId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"verified\",\"kind\":\"scalar\",\"type\":\"Boolean\"}],\"dbName\":null},\"Params\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"_id\"},{\"name\":\"ipfsObjectId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"ipfsObject\",\"kind\":\"object\",\"type\":\"IpfsObject\",\"relationName\":\"ParamsIpfs\"},{\"name\":\"commitId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"commit\",\"kind\":\"object\",\"type\":\"Commit\",\"relationName\":\"CommitToParams\"},{\"name\":\"ZKMLProof\",\"kind\":\"object\",\"type\":\"ZKMLProof\",\"relationName\":\"paramToProof\"},{\"name\":\"zkmlProofId\",\"kind\":\"scalar\",\"type\":\"String\"}],\"dbName\":null},\"SharedFolderFile\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"_id\"},{\"name\":\"branchId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"branch\",\"kind\":\"object\",\"type\":\"Branch\",\"relationName\":\"BranchToSharedFolderFile\"},{\"name\":\"committerAddress\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"metrics_after_aggregation\",\"kind\":\"scalar\",\"type\":\"Bytes\"},{\"name\":\"metrics_before_aggregation\",\"kind\":\"scalar\",\"type\":\"Bytes\"},{\"name\":\"model\",\"kind\":\"scalar\",\"type\":\"Bytes\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null},\"ZKMLProof\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"_id\"},{\"name\":\"proofIpfsId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"proof\",\"kind\":\"object\",\"type\":\"IpfsObject\",\"relationName\":\"proofIPFS\"},{\"name\":\"settingsIpfsId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"settings\",\"kind\":\"object\",\"type\":\"IpfsObject\",\"relationName\":\"settingsIPFS\"},{\"name\":\"verificationKeyIpfsId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"verification_key\",\"kind\":\"object\",\"type\":\"IpfsObject\",\"relationName\":\"verificationKeyIPFS\"},{\"name\":\"param\",\"kind\":\"object\",\"type\":\"Params\",\"relationName\":\"paramToProof\"},{\"name\":\"paramId\",\"kind\":\"scalar\",\"type\":\"String\"}],\"dbName\":null},\"MerkleTree\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"_id\"},{\"name\":\"mintAuthority\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"active\",\"kind\":\"scalar\",\"type\":\"Boolean\"},{\"name\":\"address\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"signature\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"secret\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"assetIds\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"totalLeaves\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"remainingLeaves\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null},\"Collection\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"_id\"},{\"name\":\"address\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"signature\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"privateKey\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"owner\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"repository\",\"kind\":\"object\",\"type\":\"Repository\",\"relationName\":\"CollectionToRepository\"},{\"name\":\"nft\",\"kind\":\"object\",\"type\":\"Nft\",\"relationName\":\"CollectionToNft\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"metadataCID\",\"kind\":\"scalar\",\"type\":\"String\"}],\"dbName\":null},\"Nft\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"_id\"},{\"name\":\"assetId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"merkleTreeAddress\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"signature\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"owner\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"commit\",\"kind\":\"object\",\"type\":\"Commit\",\"relationName\":\"CommitToNft\"},{\"name\":\"collection\",\"kind\":\"object\",\"type\":\"Collection\",\"relationName\":\"CollectionToNft\"},{\"name\":\"colectionId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"metadataCID\",\"kind\":\"scalar\",\"type\":\"String\"}],\"dbName\":null},\"IpfsObject\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"_id\"},{\"name\":\"cid\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"uri\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"extension\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"size\",\"kind\":\"scalar\",\"type\":\"Float\"},{\"name\":\"repositories\",\"kind\":\"object\",\"type\":\"Repository\",\"relationName\":\"RepositoryBaseModel\"},{\"name\":\"branches\",\"kind\":\"object\",\"type\":\"Branch\",\"relationName\":\"BranchLatestParams\"},{\"name\":\"params\",\"kind\":\"object\",\"type\":\"Params\",\"relationName\":\"ParamsIpfs\"},{\"name\":\"zkmlProofsProof\",\"kind\":\"object\",\"type\":\"ZKMLProof\",\"relationName\":\"proofIPFS\"},{\"name\":\"zkmlProofsSettings\",\"kind\":\"object\",\"type\":\"ZKMLProof\",\"relationName\":\"settingsIPFS\"},{\"name\":\"zkmlProofsVerification\",\"kind\":\"object\",\"type\":\"ZKMLProof\",\"relationName\":\"verificationKeyIPFS\"}],\"dbName\":null},\"CommitCreationSession\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"_id\"},{\"name\":\"jti\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"pk\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"repoId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"branchId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"status\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"expiresAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"lastErrorAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"errorCount\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"consumed\",\"kind\":\"scalar\",\"type\":\"Boolean\"},{\"name\":\"zkmlProofIpfsId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"zkmlSettingsIpfsId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"zkmlVkIpfsId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"paramsIpfsId\",\"kind\":\"scalar\",\"type\":\"String\"}],\"dbName\":null},\"InitiationBlock\":{\"fields\":[{\"name\":\"pk\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"_id\"},{\"name\":\"blockedUntil\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null}},\"enums\":{},\"types\":{}}");
async function decodeBase64AsWasm(wasmBase64) {
    const { Buffer } = await import('node:buffer');
    const wasmArray = Buffer.from(wasmBase64, 'base64');
    return new WebAssembly.Module(wasmArray);
}
config.compilerWasm = {
    getRuntime: async () => await import("@prisma/client/runtime/query_compiler_bg.mongodb.mjs"),
    getQueryCompilerWasmModule: async () => {
        const { wasm } = await import("@prisma/client/runtime/query_compiler_bg.mongodb.wasm-base64.mjs");
        return await decodeBase64AsWasm(wasm);
    }
};
export function getPrismaClientClass() {
    return runtime.getPrismaClient(config);
}
